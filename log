*repeat.txt*    Nvim
^I^I  VIM REFERENCE MANUAL    by Bram Moolenaar
Repeating commands, Vim scripts and debugging^I^I^I*repeating*
Chapter 26 of the user manual introduces repeating |usr_26.txt|.
                                      Type |gO| to see the table of contents.
==============================================================================
Single repeats^I^I^I^I^I^I*single-repeat*
^I^I^I^I^I^I^I*.*
.^I^I^IRepeat last change, with count replaced with [count].
^I^I^IAlso repeat a yank command, when the 'y' flag is
^I^I^Iincluded in 'cpoptions'.  Does not repeat a
^I^I^Icommand-line command.
Simple changes can be repeated with the "." command.  Without a count, the
count of the last change is used.  If you enter a count, it will replace the
last one.  |v:count| and |v:count1| will be set.
If the last change included a specification of a numbered register, the
register number will be incremented.  See |redo-register| for an example how
to use this.
Note that when repeating a command that used a Visual selection, the same SIZE
of area is used, see |visual-repeat|.
^I^I^I^I^I^I^I*@:*
@:^I^I^IRepeat last command-line [count] times.
==============================================================================
Multiple repeats^I^I^I^I^I*multi-repeat*
^I^I^I^I^I^I*:g* *:global* *E148*
:[range]g[lobal]/{pattern}/[cmd]
^I^I^IExecute the Ex command [cmd] (default ":p") on the
^I^I^Ilines within [range] where {pattern} matches.
:[range]g[lobal]!/{pattern}/[cmd]
^I^I^IExecute the Ex command [cmd] (default ":p") on the
^I^I^Ilines within [range] where {pattern} does NOT match.
^I^I^I^I^I^I^I*:v* *:vglobal*
:[range]v[global]/{pattern}/[cmd]
^I^I^ISame as :g!.
Example:  
^I:g/^Obsolete/d _
Using the underscore after `:d` avoids clobbering registers or the clipboard.
This also makes it faster.
Instead of the '/' which surrounds the {pattern}, you can use any other
single byte character, but not an alphabetic character, '\', '"' or '|'.
This is useful if you want to include a '/' in the search pattern or
replacement string.
For the definition of a pattern, see |pattern|.
NOTE [cmd] may contain a range; see |collapse| and |edit-paragraph-join| for
examples.
The global commands work by first scanning through the [range] lines and
marking each line where a match occurs (for a multi-line pattern, only the
start of the match matters).
In a second scan the [cmd] is executed for each marked line, as if the cursor
was in that line.  For ":v" and ":g!" the command is executed for each not
marked line.  If a line is deleted its mark disappears.
The default for [range] is the whole buffer (1,$).  Use "CTRL-C" to interrupt
the command.  If an error message is given for a line, the command for that
line is aborted and the global command continues with the next marked or
unmarked line.
^I^I^I^I^I^I^I^I*E147*
When the command is used recursively, it only works on one line.  Giving a
range is then not allowed. This is useful to find all lines that match a
pattern and do not match another pattern:  
^I:g/found/v/notfound/{cmd}
This first finds all lines containing "found", but only executes {cmd} when
there is no match for "notfound".
Any Ex command can be used, see |ex-cmd-index|.  To execute a Normal mode
command, you can use the `:normal` command:  
^I:g/pat/normal {commands}
Make sure that {commands} ends with a whole command, otherwise Vim will wait
for you to type the rest of the command for each match.  The screen will not
have been updated, so you don't know what you are doing.  See |:normal|.
The undo/redo command will undo/redo the whole global command at once.
The previous context mark will only be set once (with "''" you go back to
where the cursor was before the global command).
The global command sets both the last used search pattern and the last used
substitute pattern (this is vi compatible).  This makes it easy to globally
replace a string:
^I:g/pat/s//PAT/g
This replaces all occurrences of "pat" with "PAT".  The same can be done with:
^I:%s/pat/PAT/g
Which is two characters shorter!
When using "global" in Ex mode, a special case is using ":visual" as a
command.  This will move to a matching line, go to Normal mode to let you
execute commands there until you use |gQ| to return to Ex mode.  This will be
repeated for each matching line.  While doing this you cannot use ":global".
To abort this type CTRL-C twice.
==============================================================================
Complex repeats^I^I^I^I^I^I*complex-repeat*
^I^I^I^I^I^I^I*q* *recording*
q{0-9a-zA-Z"}^I^IRecord typed characters into register {0-9a-zA-Z"}
^I^I^I(uppercase to append).  The 'q' command is disabled
^I^I^Iwhile executing a register, and it doesn't work inside
^I^I^Ia mapping and |:normal|.
^I^I^INote: If the register being used for recording is also
^I^I^Iused for |y| and |p| the result is most likely not
^I^I^Iwhat is expected, because the put will paste the
^I^I^Irecorded macro and the yank will overwrite the
^I^I^Irecorded macro.
^I^I^INote: The recording happens while you type, replaying
^I^I^Ithe register happens as if the keys come from a
^I^I^Imapping.  This matters, for example, for undo, which
^I^I^Ionly syncs when commands were typed.
q^I^I^IStops recording.
^I^I^IImplementation note: The 'q' that stops recording is
^I^I^Inot stored in the register, unless it was the result
^I^I^Iof a mapping
^I^I^I^I^I^I^I*@*
@{0-9a-z".=*+}^I^IExecute the contents of register {0-9a-z".=*+} [count]
^I^I^Itimes.  Note that register '%' (name of the current
^I^I^Ifile) and '#' (name of the alternate file) cannot be
^I^I^Iused.
^I^I^IThe register is executed like a mapping, that means
^I^I^Ithat the difference between 'wildchar' and 'wildcharm'
^I^I^Iapplies, and undo might not be synced in the same way.
^I^I^IFor "@=" you are prompted to enter an expression.  The
^I^I^Iresult of the expression is then executed.
^I^I^ISee also |@:|.
^I^I^I^I^I^I^I*@@* *E748*
@@^I^I^IRepeat the previous @{0-9a-z":*} [count] times.
^I^I^I^I^I^I^I*Q*
Q^I^I^IRepeat the last recorded register [count] times.
^I^I^ISee |reg_recorded()|.
^I^I^I^I^I^I^I*:@*
:[addr]@{0-9a-z".=*+}^IExecute the contents of register {0-9a-z".=*+} as an Ex
^I^I^Icommand.  First set cursor at line [addr] (default is
^I^I^Icurrent line).  When the last line in the register does
^I^I^Inot have a <CR> it will be added automatically when
^I^I^Ithe 'e' flag is present in 'cpoptions'.
^I^I^IFor ":@=" the last used expression is used.  The
^I^I^Iresult of evaluating the expression is executed as an
^I^I^IEx command.
^I^I^IMappings are not recognized in these commands.
^I^I^IWhen the |line-continuation| character (\) is present
^I^I^Iat the beginning of a line in a linewise register,
^I^I^Ithen it is combined with the previous line. This is
^I^I^Iuseful for yanking and executing parts of a Vim
^I^I^Iscript.
^I^I^I^I^I^I^I*:@:*
:[addr]@:^I^IRepeat last command-line.  First set cursor at line
^I^I^I[addr] (default is current line).
:[addr]@^I^I^I^I^I^I^I*:@@*
:[addr]@@^I^IRepeat the previous :@{register}.  First set cursor at
^I^I^Iline [addr] (default is current line).
==============================================================================
Using Vim scripts^I^I^I^I^I*using-scripts*
For writing a Vim script, see chapter 41 of the user manual |usr_41.txt|.
^I^I^I^I^I*:so* *:source* *load-vim-script*
:[range]so[urce] [file]^IRuns |Ex| commands or Lua code (".lua" files) from
^I^I^I[file], or current buffer if no [file].
^I^I^ITriggers the |SourcePre| autocommand.
^I^I^I^I^I^I^I*:source!*
:[range]so[urce]! {file}
^I^I^IRuns |Normal-mode| commands from {file}. When used
^I^I^Iafter |:global|, |:argdo|, |:windo|, |:bufdo|, in
^I^I^Ia loop or when another command follows the display
^I^I^Iwon't be updated while executing the commands.
^I^I^I^I^I^I^I*:ru* *:runtime*
:ru[ntime][!] [where] {file} ..
^I^I^ISources |Ex| commands or Lua code (".lua" files) read
^I^I^Ifrom {file} (a relative path) in each directory given
^I^I^Iby 'runtimepath' and/or 'packpath'.
^I^I^IIgnores non-existing files.
^I^I^IExample:  
^I^I^I^I:runtime syntax/c.vim
^I^I^I^I:runtime syntax/c.lua
 ^I^I^IThere can be multiple space-separated {file}
^I^I^Iarguments. Each {file} is searched for in the first
^I^I^Idirectory from 'runtimepath', then in the second
^I^I^Idirectory, etc.
^I^I^IWhen [!] is included, all found files are sourced.
^I^I^IElse only the first found file is sourced.
^I^I^IWhen [where] is omitted only 'runtimepath' is used.
^I^I^IOther values:
^I^I^I^ISTART^Isearch only under "start" in 'packpath'
^I^I^I^IOPT^Isearch only under "opt" in 'packpath'
^I^I^I^IPACK^Isearch under "start" and "opt" in
^I^I^I^I^I'packpath'
^I^I^I^IALL^Ifirst use 'runtimepath', then search
^I^I^I^I^Iunder "start" and "opt" in 'packpath'
^I^I^IWhen {file} contains wildcards it is expanded to all
^I^I^Imatching files.  Example:  
^I^I^I^I:runtime! plugin/**/*.vim
 ^I^I^IThis is what Vim uses to load the plugin files when
^I^I^Istarting up.  This similar command:  
^I^I^I^I:runtime plugin/**/*.vim
 ^I^I^Iwould source the first file only.
^I^I^IWhen 'verbose' is one or higher, there is a message
^I^I^Iwhen no file could be found.
^I^I^IWhen 'verbose' is two or higher, there is a message
^I^I^Iabout each searched file.
^I^I^I^I^I^I^I*:pa* *:packadd* *E919*
:pa[ckadd][!] {name}^ISearch for an optional plugin directory in 'packpath'
^I^I^Iand source any plugin files found.  The directory must
^I^I^Imatch:
^I^I^I^Ipack/*/opt/{name}  
^I^I^IThe directory is added to 'runtimepath' if it wasn't
^I^I^Ithere yet.
^I^I^IIf the directory pack/*/opt/{name}/after exists it is
^I^I^Iadded at the end of 'runtimepath'.
^I^I^IIf loading packages from "pack/*/start" was skipped,
^I^I^Ithen this directory is searched first:
^I^I^I^Ipack/*/start/{name}  
^I^I^INote that {name} is the directory name, not the name
^I^I^Iof the .vim file.  All the files matching the pattern
^I^I^I^Ipack/*/opt/{name}/plugin/**/*.vim  
^I^I^Iand
^I^I^I^Ipack/*/opt/{name}/plugin/**/*.lua  
^I^I^Iwill be sourced.  This allows for using subdirectories
^I^I^Ibelow "plugin", just like with plugins in
^I^I^I'runtimepath'.
^I^I^IIf the filetype detection was already enabled (this
^I^I^Iis usually done with a "syntax enable" or "filetype
^I^I^Ion" command in your |init.vim|, or automatically during
^I^I^I|initialization|), and the package was found in
^I^I^I"pack/*/opt/{name}", this command will also look
^I^I^Ifor "{name}/ftdetect/*.vim" files.
^I^I^IWhen the optional ! is added no plugin files or
^I^I^Iftdetect scripts are loaded, only the matching
^I^I^Idirectories are added to 'runtimepath'.  This is
^I^I^Iuseful in your |init.vim|.  The plugins will then be
^I^I^Iloaded during |initialization|, see |load-plugins| (note
^I^I^Ithat the loading order will be reversed, because each
^I^I^Idirectory is inserted before others). In this case, the
^I^I^Iftdetect scripts will be loaded during |initialization|,
^I^I^Ibefore the |load-plugins| step.
^I^I^IAlso see |pack-add|.
^I^I^I^I^I^I*:packl* *:packloadall*
:packl[oadall][!]^ILoad all packages in the "start" directory under each
^I^I^Ientry in 'packpath'.
^I^I^IFirst all the directories found are added to
^I^I^I'runtimepath', then the plugins found in the
^I^I^Idirectories are sourced.  This allows for a plugin to
^I^I^Idepend on something of another plugin, e.g. an
^I^I^I"autoload" directory.  See |packload-two-steps| for
^I^I^Ihow this can be useful.
^I^I^IThis is normally done automatically during startup,
^I^I^Iafter loading your |vimrc| file.  With this command it
^I^I^Ican be done earlier.
^I^I^IPackages will be loaded only once.  Using
^I^I^I`:packloadall` a second time will have no effect.
^I^I^IWhen the optional ! is added this command will load
^I^I^Ipackages even when done before.
^I^I^INote that when using `:packloadall` in the |vimrc|
^I^I^Ifile, the 'runtimepath' option is updated, and later
^I^I^Iall plugins in 'runtimepath' will be loaded, which
^I^I^Imeans they are loaded again.  Plugins are expected to
^I^I^Ihandle that.
^I^I^IAn error only causes sourcing the script where it
^I^I^Ihappens to be aborted, further plugins will be loaded.
^I^I^ISee |packages|.
:scripte[ncoding] [encoding]^I^I*:scripte* *:scriptencoding* *E167*
^I^I^ISpecify the character encoding used in the script.
^I^I^IThe following lines will be converted from [encoding]
^I^I^Ito the value of the 'encoding' option, if they are
^I^I^Idifferent.  Examples:  
^I^I^I^Iscriptencoding iso-8859-5
^I^I^I^Iscriptencoding cp932
 
^I^I^IWhen [encoding] is empty, no conversion is done.  This
^I^I^Ican be used to restrict conversion to a sequence of
^I^I^Ilines:  
^I^I^I^Iscriptencoding euc-jp
^I^I^I^I... lines to be converted ...
^I^I^I^Iscriptencoding
^I^I^I^I... not converted ...
 ^I^I^IWhen conversion isn't supported by the system, there
^I^I^Iis no error message and no conversion is done.  When a
^I^I^Iline can't be converted there is no error and the
^I^I^Ioriginal line is kept.
^I^I^IDon't use "ucs-2" or "ucs-4", scripts cannot be in
^I^I^Ithese encodings (they would contain NUL bytes).
^I^I^IWhen a sourced script starts with a BOM (Byte Order
^I^I^IMark) in utf-8 format Vim will recognize it, no need
^I^I^Ito use ":scriptencoding utf-8" then.
^I^I^I^I^I^I*:scr* *:scriptnames*
:scr[iptnames]^I^IList all sourced script names, in the order they were
^I^I^Ifirst sourced.  The number is used for the script ID
^I^I^I|<SID>|.
:scr[iptnames][!] {scriptId}^I^I^I*:script*
^I^I^IEdit script {scriptId}.  Although ":scriptnames name"
^I^I^Iworks, using ":script name" is recommended.
^I^I^IWhen the current buffer can't be |abandon|ed and the !
^I^I^Iis not present, the command fails.
^I^I^I^I^I^I*:fini* *:finish* *E168*
:fini[sh]^I^IStop sourcing a script.  Can only be used in a Vim
^I^I^Iscript file.  This is a quick way to skip the rest of
^I^I^Ithe file.  If it is used after a |:try| but before the
^I^I^Imatching |:finally| (if present), the commands
^I^I^Ifollowing the ":finally" up to the matching |:endtry|
^I^I^Iare executed first.  This process applies to all
^I^I^Inested ":try"s in the script.  The outermost ":endtry"
^I^I^Ithen stops sourcing the script.
All commands and command sequences can be repeated by putting them in a named
register and then executing it.  There are two ways to get the commands in the
register:
- Use the record command "q".  You type the commands once, and while they are
  being executed they are stored in a register.  Easy, because you can see
  what you are doing.  If you make a mistake, "p"ut the register into the
  file, edit the command sequence, and then delete it into the register
  again.  You can continue recording by appending to the register (use an
  uppercase letter).
- Delete or yank the command sequence into the register.
Often used command sequences can be put under a function key with the ':map'
command.
An alternative is to put the commands in a file, and execute them with the
':source!' command.  Useful for long command sequences.  Can be combined with
the ':map' command to put complicated commands under a function key.
The ':source' command reads Ex commands from a file line by line.  You will
have to type any needed keyboard input.  The ':source!' command reads from a
script file character by character, interpreting each character as if you
typed it.
Example: When you give the ":!ls" command you get the |hit-enter| prompt.  If
you ':source' a file with the line "!ls" in it, you will have to type the
<Enter> yourself.  But if you ':source!' a file with the line ":!ls" in it,
the next characters from that file are read until a <CR> is found.  You will
not have to type <CR> yourself, unless ":!ls" was the last line in the file.
It is possible to put ':source[!]' commands in the script file, so you can
make a top-down hierarchy of script files.  The ':source' command can be
nested as deep as the number of files that can be opened at one time (about
15).  The ':source!' command can be nested up to 15 levels deep.
You can use the "<sfile>" string (literally, this is not a special key) inside
of the sourced file, in places where a file name is expected.  It will be
replaced by the file name of the sourced file.  For example, if you have a
"other.vimrc" file in the same directory as your |init.vim| file, you can
source it from your |init.vim| file with this command:  
^I:source <sfile>:h/other.vimrc
In script files terminal-dependent key codes are represented by
terminal-independent two character codes.  This means that they can be used
in the same way on different kinds of terminals.  The first character of a
key code is 0x80 or 128, shown on the screen as "~@".  The second one can be
found in the list |key-notation|.  Any of these codes can also be entered
with CTRL-V followed by the three digit decimal code.
^I^I^I^I^I^I^I*:source_crnl* *W15*
Windows: Files that are read with ":source" normally have <CR><NL> <EOL>s.
These always work.  If you are using a file with <NL> <EOL>s (for example, a
file made on Unix), this will be recognized if 'fileformats' is not empty and
the first line does not end in a <CR>.  This fails if the first line has
something like ":map <F1> :help^M", where "^M" is a <CR>.  If the first line
ends in a <CR>, but following ones don't, you will get an error message,
because the <CR> from the first lines will be lost.
On other systems, Vim expects ":source"ed files to end in a <NL>.  These
always work.  If you are using a file with <CR><NL> <EOL>s (for example, a
file made on MS-Windows), all lines will have a trailing <CR>.  This may cause
problems for some commands (e.g., mappings).  There is no automatic <EOL>
detection, because it's common to start with a line that defines a mapping
that ends in a <CR>, which will confuse the automaton.
^I^I^I^I^I^I^I*line-continuation*
Long lines in a ":source"d Ex command script file can be split by inserting
a line continuation symbol "\" (backslash) at the start of the next line.
There can be white space before the backslash, which is ignored.
Example: the lines  
^I:set comments=sr:/*,mb:*,el:*/,
^I^I     \://,
^I^I     \b:#,
^I^I     \:%,
^I^I     \n:>,
^I^I     \fb:-
are interpreted as if they were given in one line:
^I:set comments=sr:/*,mb:*,el:*/,://,b:#,:%,n:>,fb:-
All leading whitespace characters in the line before a backslash are ignored.
Note however that trailing whitespace in the line before it cannot be
inserted freely; it depends on the position where a command is split up
whether additional whitespace is allowed or not.
When a space is required it's best to put it right after the backslash.  A
space at the end of a line is hard to see and may be accidentally deleted.  
^I:syn match Comment
^I^I\ "very long regexp"
^I^I\ keepend
There is a problem with the ":append" and ":insert" commands:  
   :1append
   \asdf
   .
The backslash is seen as a line-continuation symbol, thus this results in the
command:  
   :1appendasdf
   .
To avoid this, add the 'C' flag to the 'cpoptions' option:  
   :set cpo+=C
   :1append
   \asdf
   .
   :set cpo-=C
Note that when the commands are inside a function, you need to add the 'C'
flag when defining the function, it is not relevant when executing it.  
   :set cpo+=C
   :function Foo()
   :1append
   \asdf
   .
   :endfunction
   :set cpo-=C
 
^I^I^I^I^I*line-continuation-comment*
To add a comment in between the lines start with `'"\ '`.  Notice the space
after the backslash.  Example:  
^Ilet array = [
^I^I"\ first entry comment
^I^I\ 'first',
^I^I"\ second entry comment
^I^I\ 'second',
^I^I\ ]
Rationale:
^IMost programs work with a trailing backslash to indicate line
^Icontinuation.  Using this in Vim would cause incompatibility with Vi.
^IFor example for this Vi mapping:  
^I^I:map xx  asdf\
 ^ITherefore the unusual leading backslash is used.
^IStarting a comment in a continuation line results in all following
^Icontinuation lines to be part of the comment.  Since it was like this
^Ifor a long time, when making it possible to add a comment halfway a
^Isequence of continuation lines, it was not possible to use \", since
^Ithat was a valid continuation line.  Using `'"\ '` comes closest, even
^Ithough it may look a bit weird.  Requiring the space after the
^Ibackslash is to make it very unlikely this is a normal comment line.
==============================================================================
Using Vim packages^I^I^I^I^I*packages*
A Vim "package" is a directory that contains |plugin|s.  Compared to normal
plugins, a package can...
- be downloaded as an archive and unpacked in its own directory, so the files
  are not mixed with files of other plugins.
- be a git, mercurial, etc. repository, thus easy to update.
- contain multiple plugins that depend on each other.
- contain plugins that are automatically loaded on startup ("start" packages,
  located in "pack/*/start/*") and ones that are only loaded when needed with
  |:packadd| ("opt" packages, located in "pack/*/opt/*").
^I^I^I^I^I^I^I*runtime-search-path*
Nvim searches for |:runtime| files in:
^I1. all paths in 'runtimepath'
^I2. all "pack/*/start/*" dirs
Note that the "pack/*/start/*" paths are not explicitly included in
'runtimepath', so they will not be reported by ":set rtp" or "echo &rtp".
Scripts can use |nvim_list_runtime_paths()| to list all used directories, and
|nvim_get_runtime_file()| to query for specific files or sub-folders within
the runtime path. Example:  
^I" List all runtime dirs and packages with Lua paths.
^I:echo nvim_get_runtime_file("lua/", v:true)
Using a package and loading automatically  
Let's assume your Nvim files are in "~/.local/share/nvim/site" and you want to
add a package from a zip archive "/tmp/foopack.zip":
^I% mkdir -p ~/.local/share/nvim/site/pack/foo
^I% cd ~/.local/share/nvim/site/pack/foo
^I% unzip /tmp/foopack.zip
The directory name "foo" is arbitrary, you can pick anything you like.
You would now have these files under ~/.local/share/nvim/site:
^Ipack/foo/README.txt
^Ipack/foo/start/foobar/plugin/foo.vim
^Ipack/foo/start/foobar/syntax/some.vim
^Ipack/foo/opt/foodebug/plugin/debugger.vim
On startup after processing your |config|, Nvim scans all directories in
'packpath' for plugins in "pack/*/start/*", then loads the plugins.
To allow for calling into package functionality while parsing your |vimrc|,
|:colorscheme| and |autoload| will both automatically search under 'packpath'
as well in addition to 'runtimepath'.  See the documentation for each for
details.
In the example Nvim will find "pack/foo/start/foobar/plugin/foo.vim" and load
it.
If the "foobar" plugin kicks in and sets the 'filetype' to "some", Nvim will
find the syntax/some.vim file, because its directory is in the runtime search
path.
Nvim will also load ftdetect files, if there are any.
Note that the files under "pack/foo/opt" are not loaded automatically, only the
ones under "pack/foo/start".  See |pack-add| below for how the "opt" directory
is used.
Loading packages automatically will not happen if loading plugins is disabled,
see |load-plugins|.
To load packages earlier, so that plugin/ files are sourced:
^I:packloadall
This also works when loading plugins is disabled.  The automatic loading will
only happen once.
If the package has an "after" directory, that directory is added to the end of
'runtimepath', so that anything there will be loaded later.
Using a single plugin and loading it automatically  
If you don't have a package but a single plugin, you need to create the extra
directory level:
^I% mkdir -p ~/.local/share/nvim/site/pack/foo/start/foobar
^I% cd ~/.local/share/nvim/site/pack/foo/start/foobar
^I% unzip /tmp/someplugin.zip
You would now have these files:
^Ipack/foo/start/foobar/plugin/foo.vim
^Ipack/foo/start/foobar/syntax/some.vim
From here it works like above.
Optional plugins  
^I^I^I^I^I^I^I*pack-add*
To load an optional plugin from a pack use the `:packadd` command:  
^I:packadd foodebug
This searches for "pack/*/opt/foodebug" in 'packpath' and will find
~/.local/share/nvim/site/pack/foo/opt/foodebug/plugin/debugger.vim and source
it.
This could be done if some conditions are met.  For example, depending on
whether Nvim supports a feature or a dependency is missing.
You can also load an optional plugin at startup, by putting this command in
your |config|:  
^I:packadd! foodebug
The extra "!" is so that the plugin isn't loaded if Nvim was started with
|--noplugin|.
It is perfectly normal for a package to only have files in the "opt"
directory.  You then need to load each plugin when you want to use it.
Where to put what  
Since color schemes, loaded with `:colorscheme`, are found below
"pack/*/start" and "pack/*/opt", you could put them anywhere.  We recommend
you put them below "pack/*/opt", for example
"~/.config/nvim/pack/mycolors/opt/dark/colors/very_dark.vim".
Filetype plugins should go under "pack/*/start", so that they are always
found.  Unless you have more than one plugin for a file type and want to
select which one to load with `:packadd`.  E.g. depending on the compiler
version:  
^Iif foo_compiler_version > 34
^I  packadd foo_new
^Ielse
^I  packadd foo_old
^Iendif
The "after" directory is most likely not useful in a package.  It's not
disallowed though.
==============================================================================
Creating Vim packages^I^I^I^I^I*package-create*
This assumes you write one or more plugins that you distribute as a package.
If you have two unrelated plugins you would use two packages, so that Vim
users can choose what they include or not.  Or you can decide to use one
package with optional plugins, and tell the user to add the preferred ones with
`:packadd`.
Decide how you want to distribute the package.  You can create an archive or
you could use a repository.  An archive can be used by more users, but is a
bit harder to update to a new version.  A repository can usually be kept
up-to-date easily, but it requires a program like "git" to be available.
You can do both, github can automatically create an archive for a release.
Your directory layout would be like this:
   start/foobar/plugin/foo.vim^I^I" always loaded, defines commands
   start/foobar/plugin/bar.vim^I^I" always loaded, defines commands
   start/foobar/autoload/foo.vim^I" loaded when foo command used
   start/foobar/doc/foo.txt^I^I" help for foo.vim
   start/foobar/doc/tags^I^I" help tags
   opt/fooextra/plugin/extra.vim^I" optional plugin, defines commands
   opt/fooextra/autoload/extra.vim^I" loaded when extra command used
   opt/fooextra/doc/extra.txt^I^I" help for extra.vim
   opt/fooextra/doc/tags^I^I" help tags
This allows for the user to do:  
^Imkdir ~/.local/share/nvim/site/pack
^Icd ~/.local/share/nvim/site/pack
^Igit clone https://github.com/you/foobar.git myfoobar
Here "myfoobar" is a name that the user can choose, the only condition is that
it differs from other packages.
In your documentation you explain what the plugins do, and tell the user how
to load the optional plugin:  
^I:packadd! fooextra
You could add this packadd command in one of your plugins, to be executed when
the optional plugin is needed.
Run the `:helptags` command to generate the doc/tags file.  Including this
generated file in the package means that the user can drop the package in the
pack directory and the help command works right away.  Don't forget to re-run
the command after changing the plugin help:  
^I:helptags path/start/foobar/doc
^I:helptags path/opt/fooextra/doc
Dependencies between plugins  
^I^I^I^I^I^I^I*packload-two-steps*
Suppose you have two plugins that depend on the same functionality. You can
put the common functionality in an autoload directory, so that it will be
found automatically.  Your package would have these files:
^Ipack/foo/start/one/plugin/one.vim   
^I^Icall foolib#getit()
 ^Ipack/foo/start/two/plugin/two.vim  
^I^Icall foolib#getit()
 ^Ipack/foo/start/lib/autoload/foolib.vim  
^I^Ifunc foolib#getit()
This works, because start packages will be searched for autoload files, when
sourcing the plugins.
==============================================================================
Debugging scripts^I^I^I^I^I*debug-scripts*
Besides the obvious messages that you can add to your scripts to find out what
they are doing, Vim offers a debug mode.  This allows you to step through a
sourced file or user function and set breakpoints.
NOTE: The debugging mode is far from perfect.  Debugging will have side
effects on how Vim works.  You cannot use it to debug everything.  For
example, the display is messed up by the debugging messages.
An alternative to debug mode is setting the 'verbose' option.  With a bigger
number it will give more verbose messages about what Vim is doing.
STARTING DEBUG MODE^I^I^I^I^I^I*debug-mode*
To enter debugging mode use one of these methods:
1. Start Vim with the |-D| argument:  
^Ivim -D file.txt
   Debugging will start as soon as the first vimrc file is sourced.  This is
   useful to find out what is happening when Vim is starting up.  A side
   effect is that Vim will switch the terminal mode before initialisations
   have finished, with unpredictable results.
   For a GUI-only version (Windows) the debugging will start as
   soon as the GUI window has been opened.  To make this happen early, add a
   ":gui" command in the vimrc file.
^I^I^I^I^I^I^I^I*:debug*
2. Run a command with ":debug" prepended.  Debugging will only be done while
   this command executes.  Useful for debugging a specific script or user
   function.  And for scripts and functions used by autocommands.  Example:  
^I:debug edit test.txt.gz
3. Set a breakpoint in a sourced file or user function.  You could do this in
   the command line:  
^Ivim -c "breakadd file */explorer.vim" .
   This will run Vim and stop in the first line of the "explorer.vim" script.
   Breakpoints can also be set while in debugging mode.
In debugging mode every executed command is displayed before it is executed.
Comment lines, empty lines and lines that are not executed are skipped.  When
a line contains two commands, separated by "|", each command will be displayed
separately.
DEBUG MODE
Once in debugging mode, the usual Ex commands can be used.  For example, to
inspect the value of a variable:  
^Iecho idx
When inside a user function, this will print the value of the local variable
"idx".  Prepend "g:" to get the value of a global variable:  
^Iecho g:idx
All commands are executed in the context of the current function or script.
You can also set options, for example setting or resetting 'verbose' will show
what happens, but you might want to set it just before executing the lines you
are interested in:  
^I:set verbose=20
Commands that require updating the screen should be avoided, because their
effect won't be noticed until after leaving debug mode.  For example:  
^I:help
won't be very helpful.
There is a separate command-line history for debug mode.
The line number for a function line is relative to the start of the function.
If you have trouble figuring out where you are, edit the file that defines
the function in another Vim, search for the start of the function and do
"99j".  Replace "99" with the line number.
Additionally, these commands can be used:
^I^I^I^I^I^I^I*>cont*
^Icont^I^IContinue execution until the next breakpoint is hit.
^I^I^I^I^I^I^I*>quit*
^Iquit^I^IAbort execution.  This is like using CTRL-C, some
^I^I^Ithings might still be executed, doesn't abort
^I^I^Ieverything.  Still stops at the next breakpoint.
^I^I^I^I^I^I^I*>next*
^Inext^I^IExecute the command and come back to debug mode when
^I^I^Iit's finished.  This steps over user function calls
^I^I^Iand sourced files.
^I^I^I^I^I^I^I*>step*
^Istep^I^IExecute the command and come back to debug mode for
^I^I^Ithe next command.  This steps into called user
^I^I^Ifunctions and sourced files.
^I^I^I^I^I^I^I*>interrupt*
^Iinterrupt^IThis is like using CTRL-C, but unlike ">quit" comes
^I^I^Iback to debug mode for the next command that is
^I^I^Iexecuted.  Useful for testing |:finally| and |:catch|
^I^I^Ion interrupt exceptions.
^I^I^I^I^I^I^I*>finish*
^Ifinish^I^IFinish the current script or user function and come
^I^I^Iback to debug mode for the command after the one that
^I^I^Isourced or called it.
^I^I^I^I^I^I^I*>bt*
^I^I^I^I^I^I^I*>backtrace*
^I^I^I^I^I^I^I*>where*
^Ibacktrace^IShow the call stacktrace for current debugging session.
^Ibt
^Iwhere
^I^I^I^I^I^I^I*>frame*
^Iframe N^I^IGoes to N backtrace level. + and - signs make movement
^I^I^Irelative.  E.g., ":frame +3" goes three frames up.
^I^I^I^I^I^I^I*>up*
^Iup^I^IGoes one level up from call stacktrace.
^I^I^I^I^I^I^I*>down*
^Idown^I^IGoes one level down from call stacktrace.
About the additional commands in debug mode:
- There is no command-line completion for them, you get the completion for the
  normal Ex commands only.
- You can shorten them, up to a single character, unless more than one command
  starts with the same letter.  "f" stands for "finish", use "fr" for "frame".
- Hitting <CR> will repeat the previous one.  When doing another command, this
  is reset (because it's not clear what you want to repeat).
- When you want to use the Ex command with the same name, prepend a colon:
  ":cont", ":next", ":finish" (or shorter).
The backtrace shows the hierarchy of function calls, e.g.:
^I>bt  
^I  3 function One[3]  
^I  2 Two[3]  
^I->1 Three[3]  
^I  0 Four  
^Iline 1: let four = 4  
The "->" points to the current frame.  Use "up", "down" and "frame N" to
select another frame.
In the current frame you can evaluate the local function variables.  There is
no way to see the command at the current line yet.
DEFINING BREAKPOINTS
^I^I^I^I^I^I^I*:breaka* *:breakadd*
:breaka[dd] func [lnum] {name}
^I^ISet a breakpoint in a function.  Example:  
^I^I^I:breakadd func Explore
 ^I^IDoesn't check for a valid function name, thus the breakpoint
^I^Ican be set before the function is defined.
:breaka[dd] file [lnum] {name}
^I^ISet a breakpoint in a sourced file.  Example:  
^I^I^I:breakadd file 43 init.vim
:breaka[dd] here
^I^ISet a breakpoint in the current line of the current file.
^I^ILike doing:  
^I^I^I:breakadd file <cursor-line> <current-file>
 ^I^INote that this only works for commands that are executed when
^I^Isourcing the file, not for a function defined in that file.
:breaka[dd] expr {expression}
^I^ISets a breakpoint, that will break whenever the {expression}
^I^Ievaluates to a different value. Example:  
^I^I^I:breakadd expr g:lnum
 ^I^IWill break, whenever the global variable lnum changes.
^I^IErrors in evaluation are suppressed, you can use the name of a
^I^Ivariable that does not exist yet.  This also means you will
^I^Inot notice anything if the expression has a mistake.
^I^INote if you watch a |script-variable| this will break
^I^Iwhen switching scripts, since the script variable is only
^I^Ivalid in the script where it has been defined and if that
^I^Iscript is called from several other scripts, this will stop
^I^Iwhenever that particular variable will become visible or
^I^Iinaccessible again.
The [lnum] is the line number of the breakpoint.  Vim will stop at or after
this line.  When omitted line 1 is used.
^I^I^I^I^I^I^I*:debug-name*
{name} is a pattern that is matched with the file or function name.  The
pattern is like what is used for autocommands.  There must be a full match (as
if the pattern starts with "^" and ends in "$").  A "*" matches any sequence
of characters.  'ignorecase' is not used, but "\c" can be used in the pattern
to ignore case |/\c|.  Don't include the () for the function name!
The match for sourced scripts is done against the full file name.  If no path
is specified the current directory is used.  Examples:  
^Ibreakadd file explorer.vim
matches "explorer.vim" in the current directory.  
^Ibreakadd file *explorer.vim
matches ".../plugin/explorer.vim", ".../plugin/iexplorer.vim", etc.  
^Ibreakadd file */explorer.vim
matches ".../plugin/explorer.vim" and "explorer.vim" in any other directory.
The match for functions is done against the name as it's shown in the output
of ":function".  For local functions this means that something like "<SNR>99_"
is prepended.
Note that functions are first loaded and later executed.  When they are loaded
the "file" breakpoints are checked, when they are executed the "func"
breakpoints.
DELETING BREAKPOINTS
^I^I^I^I^I^I*:breakd* *:breakdel* *E161*
:breakd[el] {nr}
^I^IDelete breakpoint {nr}.  Use |:breaklist| to see the number of
^I^Ieach breakpoint.
:breakd[el] *
^I^IDelete all breakpoints.
:breakd[el] func [lnum] {name}
^I^IDelete a breakpoint in a function.
:breakd[el] file [lnum] {name}
^I^IDelete a breakpoint in a sourced file.
:breakd[el] here
^I^IDelete a breakpoint at the current line of the current file.
When [lnum] is omitted, the first breakpoint in the function or file is
deleted.
The {name} must be exactly the same as what was typed for the ":breakadd"
command.  "explorer", "*explorer.vim" and "*explorer*" are different.
LISTING BREAKPOINTS
^I^I^I^I^I^I^I*:breakl* *:breaklist*
:breakl[ist]
^I^IList all breakpoints.
OBSCURE
^I^I^I^I^I^I*:debugg* *:debuggreedy*
:debugg[reedy]
^I^IRead debug mode commands from the normal input stream, instead
^I^Iof getting them directly from the user.  Only useful for test
^I^Iscripts.  Example:  
^I^I  echo 'q^Mq' | vim -e -s -c debuggreedy -c 'breakadd file script.vim' -S script.vim
:0debugg[reedy]
^I^IUndo ":debuggreedy": get debug mode commands directly from the
^I^Iuser, don't use typeahead for debug commands.
==============================================================================
Profiling^I^I^I^I^I^I*profile* *profiling*
Profiling means that Vim measures the time that is spent on executing
functions and/or scripts.
You can also use the |reltime()| function to measure time.
For profiling syntax highlighting see |:syntime|.
For example, to profile the one_script.vim script file:  
^I:profile start /tmp/one_script_profile
^I:profile file one_script.vim
^I:source one_script.vim
^I:exit
:prof[ile] start {fname}^I^I^I*:prof* *:profile* *E750*
^I^IStart profiling, write the output in {fname} upon exit.
^I^I"~/" and environment variables in {fname} will be expanded.
^I^IIf {fname} already exists it will be silently overwritten.
^I^IThe variable |v:profiling| is set to one.
:prof[ile] stop
^I^IWrite the logfile and stop profiling.
:prof[ile] pause
^I^IDon't profile until the following ":profile continue".  Can be
^I^Iused when doing something that should not be counted (e.g., an
^I^Iexternal command).  Does not nest.
:prof[ile] continue
^I^IContinue profiling after ":profile pause".
:prof[ile] func {pattern}
^I^IProfile function that matches the pattern {pattern}.
^I^ISee |:debug-name| for how {pattern} is used.
:prof[ile][!] file {pattern}
^I^IProfile script file that matches the pattern {pattern}.
^I^ISee |:debug-name| for how {pattern} is used.
^I^IThis only profiles the script itself, not the functions
^I^Idefined in it.
^I^IWhen the [!] is added then all functions defined in the script
^I^Iwill also be profiled.
^I^INote that profiling only starts when the script is loaded
^I^Iafter this command.  A :profile command in the script itself
^I^Iwon't work.
:prof[ile] dump
^I^IDon't wait until exiting Vim and write the current state of
^I^Iprofiling to the log immediately.
:profd[el] ...^I^I^I^I^I^I*:profd* *:profdel*
^I^IStop profiling for the arguments specified. See |:breakdel|
^I^Ifor the arguments.
You must always start with a ":profile start fname" command.  The resulting
file is written when Vim exits.  Here is an example of the output, with line
numbers prepended for the explanation:
  1 FUNCTION  Test2()  
  2 Called 1 time  
  3 Total time:   0.155251  
  4  Self time:   0.002006  
  5   
  6 count  total (s)   self (s)  
  7^I9^I       0.000096   for i in range(8)  
  8^I8   0.153655   0.000410     call Test3()  
  9^I8^I       0.000070   endfor  
 10^I^I^I^I  " Ask a question  
 11^I1^I       0.001341   echo input("give me an answer: ")  
The header (lines 1-4) gives the time for the whole function.  The "Total"
time is the time passed while the function was executing.  The "Self" time is
the "Total" time reduced by time spent in:
- other user defined functions
- sourced scripts
- executed autocommands
- external (shell) commands
Lines 7-11 show the time spent in each executed line.  Lines that are not
executed do not count.  Thus a comment line is never counted.
The Count column shows how many times a line was executed.  Note that the
"for" command in line 7 is executed one more time as the following lines.
That is because the line is also executed to detect the end of the loop.
The time Vim spends waiting for user input isn't counted at all.  Thus how
long you take to respond to the input() prompt is irrelevant.
Profiling should give a good indication of where time is spent, but keep in
mind there are various things that may clobber the results:
- Real elapsed time is measured, if other processes are busy they may cause
  delays at unpredictable moments.  You may want to run the profiling several
  times and use the lowest results.
- If you have several commands in one line you only get one time.  Split the
  line to see the time for the individual commands.
- The time of the lines added up is mostly less than the time of the whole
  function.  There is some overhead in between.
- Functions that are deleted before Vim exits will not produce profiling
  information.  You can check the |v:profiling| variable if needed:  
^I:if !v:profiling
^I:   delfunc MyFunc
^I:endif
 
- Profiling may give weird results on multi-processor systems, when sleep
  mode kicks in or the processor frequency is reduced to save power.
- The "self" time is wrong when a function is used recursively.
==============================================================================
Context^I^I^I^I^I^I^I*Context* *context*
The editor state is represented by the Context concept. This includes things
like the current |jumplist|, values of |registers|, and more, described below.
^I^I^I^I^I^I^I*context-types*
The following Context items are supported:
^I"jumps"^I^I|jumplist|
^I"regs"^I^I|registers|
^I"bufs"^I^I|buffer-list|
^I"gvars"^I^I|global-variable|s
^I"sfuncs"^I|script-local| functions
^I"funcs"^I^Iglobal and |script-local| functions
^I^I^I^I^I^I^I*context-dict*
Context objects are dictionaries with the following key-value pairs:
- "jumps", "regs", "bufs", "gvars":
      |readfile()|-style |List| representation of corresponding msgpack
      objects (see |msgpackdump()| and |msgpackparse()|).
- "funcs" (includes |script-local| functions as well):
      |List| of |:function| definitions.
^I^I^I^I^I^I^I*context-stack*
An initially-empty internal Context stack is maintained by the ctx-family
functions (see |ctx-functions|).
 vim:tw=78:ts=8:noet:ft=help:norl: